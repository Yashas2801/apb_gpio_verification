// driver.v
module driver(
  input  wire clk,
  output reg  reset,
  output reg  load,
  output reg  ce,
  output reg  flag,      // 1 => up, 0 => down
  output reg [3:0] din
);

initial begin
  // leave in known state
  reset = 1'b0;
  load  = 1'b0;
  ce    = 1'b0;
  flag  = 1'b1;   // default up
  din   = 4'b0000;
end

// API: initialize driver signals (can be called from top)
task init_driver;
  begin
    @(negedge clk);
    reset = 1'b0;
    load  = 1'b0;
    ce    = 1'b0;
    flag  = 1'b1;
    din   = 4'b0000;
  end
endtask

// API: pulse reset for 'cycles' clock cycles (assert on posedge)
task pulse_reset(input integer cycles);
  integer i;
  begin
    // assert reset asynchronously -> keep high across posedges for cycles
    reset = 1'b1;
    for (i = 0; i < cycles; i = i + 1) begin
      @(posedge clk);
    end
    reset = 1'b0;
    @(negedge clk);
  end
endtask

// API: drive load with data for one cycle
task drive_load(input [3:0] data);
  begin
    @(negedge clk);
    din  = data;
    load = 1'b1;
    // ensure load is sampled on next posedge
    @(posedge clk);
    @(negedge clk);
    load = 1'b0;
  end
endtask

// API: drive a single count operation: set ce and flag for one cycle
task drive_count_once(input bit enable, input bit up_flag);
  begin
    @(negedge clk);
    ce   = enable;
    flag = up_flag;
    @(posedge clk);
    @(negedge clk);
    ce = 1'b0;
  end
endtask

// API: set multiple signals atomically at next negedge
task set_signals(
  input bit rst_in,
  input bit ld,
  input bit ce_in,
  input bit flg,
  input [3:0] d
);
  begin
    @(negedge clk);
    reset = rst_in;
    load  = ld;
    ce    = ce_in;
    flag  = flg;
    din   = d;
  end
endtask

// API: random sequence of n operations (mix of loads and counts)
task drive_random_seq(input integer n);
  integer i;
  reg [3:0] r_d;
  reg [1:0] op;
  begin
    for (i = 0; i < n; i = i + 1) begin
      r_d = $random % 10;        // decimal digit 0..9
      op  = $random % 3;
      case (op)
        0: drive_load(r_d);                      // load
        1: drive_count_once(1'b1, $random % 2); // count once up/down
        2: begin                                // random hold/no-op with CE=0
             @(negedge clk);
             ce = 1'b0;
             load = 1'b0;
             @(posedge clk);
             @(negedge clk);
           end
      endcase
      #2; // small gap
    end
  end
endtask

endmodule
